// automatically generated by the FlatBuffers compiler, do not modify

import FlatBuffers

public enum TechPaws {
public enum Schemes {

public enum RenderCommandType: Int8, Enum { 
	public typealias T = Int8
	public static var byteSize: Int { return MemoryLayout<Int8>.size }
	public var value: Int8 { return self.rawValue }
	case pushcolor = 0
	case pushpos2f = 1
	case pushsize2f = 2
	case pushtexture = 3
	case setcoloruniform = 4
	case pushcolorshader = 5
	case pushtextureshader = 6
	case drawlines = 7
	case drawpoints = 8
	case drawquads = 9


	public static var max: RenderCommandType { return .drawquads }
	public static var min: RenderCommandType { return .pushcolor }
}

public enum ExecutionCommandType: Int8, Enum { 
	public typealias T = Int8
	public static var byteSize: Int { return MemoryLayout<Int8>.size }
	public var value: Int8 { return self.rawValue }
	case pushpos2f = 0
	case updatecameraposition = 1


	public static var max: ExecutionCommandType { return .updatecameraposition }
	public static var min: ExecutionCommandType { return .pushpos2f }
}

public enum RequestCommandType: Int8, Enum { 
	public typealias T = Int8
	public static var byteSize: Int { return MemoryLayout<Int8>.size }
	public var value: Int8 { return self.rawValue }
	case setviewportsize = 0
	case ontouchstart = 1
	case ontouchend = 2
	case ontouchmove = 3


	public static var max: RequestCommandType { return .ontouchmove }
	public static var min: RequestCommandType { return .setviewportsize }
}

public struct Vec2f: Readable {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Struct
	public static var size = 8
	public static var alignment = 4	
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

	public var x: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
	public var y: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
}

public struct Vec2i: Readable {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Struct
	public static var size = 8
	public static var alignment = 4	
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

	public var x: Int32 { return _accessor.readBuffer(of: Int32.self, at: 0) }
	public var y: Int32 { return _accessor.readBuffer(of: Int32.self, at: 4) }
}

public struct Color: Readable {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Struct
	public static var size = 16
	public static var alignment = 4	
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Struct(bb: bb, position: o) }

	public var r: Float32 { return _accessor.readBuffer(of: Float32.self, at: 0) }
	public var g: Float32 { return _accessor.readBuffer(of: Float32.self, at: 4) }
	public var b: Float32 { return _accessor.readBuffer(of: Float32.self, at: 8) }
	public var a: Float32 { return _accessor.readBuffer(of: Float32.self, at: 12) }
}

public static func createVec2f(x: Float32, y: Float32) -> UnsafeMutableRawPointer {
	let memory = UnsafeMutableRawPointer.allocate(byteCount: Vec2f.size, alignment: Vec2f.alignment)
	memory.initializeMemory(as: UInt8.self, repeating: 0, count: Vec2f.size)
	memory.storeBytes(of: x, toByteOffset: 0, as: Float32.self)
	memory.storeBytes(of: y, toByteOffset: 4, as: Float32.self)
	return memory
}

public static func createVec2i(x: Int32, y: Int32) -> UnsafeMutableRawPointer {
	let memory = UnsafeMutableRawPointer.allocate(byteCount: Vec2i.size, alignment: Vec2i.alignment)
	memory.initializeMemory(as: UInt8.self, repeating: 0, count: Vec2i.size)
	memory.storeBytes(of: x, toByteOffset: 0, as: Int32.self)
	memory.storeBytes(of: y, toByteOffset: 4, as: Int32.self)
	return memory
}

public static func createColor(r: Float32, g: Float32, b: Float32, a: Float32) -> UnsafeMutableRawPointer {
	let memory = UnsafeMutableRawPointer.allocate(byteCount: Color.size, alignment: Color.alignment)
	memory.initializeMemory(as: UInt8.self, repeating: 0, count: Color.size)
	memory.storeBytes(of: r, toByteOffset: 0, as: Float32.self)
	memory.storeBytes(of: g, toByteOffset: 4, as: Float32.self)
	memory.storeBytes(of: b, toByteOffset: 8, as: Float32.self)
	memory.storeBytes(of: a, toByteOffset: 12, as: Float32.self)
	return memory
}

public struct Data: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsData(bb: ByteBuffer) -> Data { return Data(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var color: TechPaws.Schemes.Color? { let o = _accessor.offset(4); return o == 0 ? nil : TechPaws.Schemes.Color(_accessor.bb, o: o + _accessor.postion) }
	public var vec2f: TechPaws.Schemes.Vec2f? { let o = _accessor.offset(6); return o == 0 ? nil : TechPaws.Schemes.Vec2f(_accessor.bb, o: o + _accessor.postion) }
	public var vec2i: TechPaws.Schemes.Vec2i? { let o = _accessor.offset(8); return o == 0 ? nil : TechPaws.Schemes.Vec2i(_accessor.bb, o: o + _accessor.postion) }
	public static func startData(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 3) }
	public static func add(color: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(structOffset: 0) }
	public static func add(vec2f: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(structOffset: 1) }
	public static func add(vec2i: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(structOffset: 2) }
	public static func endData(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createData(_ fbb: FlatBufferBuilder,
		offsetOfColor color: Offset<UOffset> = Offset(),
		offsetOfVec2f vec2f: Offset<UOffset> = Offset(),
		offsetOfVec2i vec2i: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = Data.startData(fbb)
		Data.add(color: color, fbb)
		Data.add(vec2f: vec2f, fbb)
		Data.add(vec2i: vec2i, fbb)
		return Data.endData(fbb, start: __start)
	}
}

public struct RenderCommand: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsRenderCommand(bb: ByteBuffer) -> RenderCommand { return RenderCommand(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var type: TechPaws.Schemes.RenderCommandType { let o = _accessor.offset(4); return o == 0 ? .pushcolor : TechPaws.Schemes.RenderCommandType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .pushcolor }
	public var data: TechPaws.Schemes.Data? { let o = _accessor.offset(6); return o == 0 ? nil : TechPaws.Schemes.Data(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startRenderCommand(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(type: TechPaws.Schemes.RenderCommandType, _ fbb: FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: 0) }
	public static func add(data: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: data, at: 1)  }
	public static func endRenderCommand(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createRenderCommand(_ fbb: FlatBufferBuilder,
		type: TechPaws.Schemes.RenderCommandType = .pushcolor,
		offsetOfData data: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = RenderCommand.startRenderCommand(fbb)
		RenderCommand.add(type: type, fbb)
		RenderCommand.add(data: data, fbb)
		return RenderCommand.endRenderCommand(fbb, start: __start)
	}
}

public struct ExecutionCommand: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsExecutionCommand(bb: ByteBuffer) -> ExecutionCommand { return ExecutionCommand(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var type: TechPaws.Schemes.ExecutionCommandType { let o = _accessor.offset(4); return o == 0 ? .pushpos2f : TechPaws.Schemes.ExecutionCommandType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .pushpos2f }
	public var data: TechPaws.Schemes.Data? { let o = _accessor.offset(6); return o == 0 ? nil : TechPaws.Schemes.Data(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startExecutionCommand(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(type: TechPaws.Schemes.ExecutionCommandType, _ fbb: FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: 0) }
	public static func add(data: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: data, at: 1)  }
	public static func endExecutionCommand(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createExecutionCommand(_ fbb: FlatBufferBuilder,
		type: TechPaws.Schemes.ExecutionCommandType = .pushpos2f,
		offsetOfData data: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = ExecutionCommand.startExecutionCommand(fbb)
		ExecutionCommand.add(type: type, fbb)
		ExecutionCommand.add(data: data, fbb)
		return ExecutionCommand.endExecutionCommand(fbb, start: __start)
	}
}

public struct RequestCommand: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsRequestCommand(bb: ByteBuffer) -> RequestCommand { return RequestCommand(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var type: TechPaws.Schemes.RequestCommandType { let o = _accessor.offset(4); return o == 0 ? .setviewportsize : TechPaws.Schemes.RequestCommandType(rawValue: _accessor.readBuffer(of: Int8.self, at: o)) ?? .setviewportsize }
	public var data: TechPaws.Schemes.Data? { let o = _accessor.offset(6); return o == 0 ? nil : TechPaws.Schemes.Data(_accessor.bb, o: _accessor.indirect(o + _accessor.postion)) }
	public static func startRequestCommand(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 2) }
	public static func add(type: TechPaws.Schemes.RequestCommandType, _ fbb: FlatBufferBuilder) { fbb.add(element: type.rawValue, def: 0, at: 0) }
	public static func add(data: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: data, at: 1)  }
	public static func endRequestCommand(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createRequestCommand(_ fbb: FlatBufferBuilder,
		type: TechPaws.Schemes.RequestCommandType = .setviewportsize,
		offsetOfData data: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = RequestCommand.startRequestCommand(fbb)
		RequestCommand.add(type: type, fbb)
		RequestCommand.add(data: data, fbb)
		return RequestCommand.endRequestCommand(fbb, start: __start)
	}
}

public struct RenderCommands: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsRenderCommands(bb: ByteBuffer) -> RenderCommands { return RenderCommands(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var commandsCount: Int32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func commands(at index: Int32) -> TechPaws.Schemes.RenderCommand? { let o = _accessor.offset(4); return o == 0 ? nil : TechPaws.Schemes.RenderCommand(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public static func startRenderCommands(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func addVectorOf(commands: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: commands, at: 0)  }
	public static func endRenderCommands(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createRenderCommands(_ fbb: FlatBufferBuilder,
		vectorOfCommands commands: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = RenderCommands.startRenderCommands(fbb)
		RenderCommands.addVectorOf(commands: commands, fbb)
		return RenderCommands.endRenderCommands(fbb, start: __start)
	}
}

public struct ExecutionCommands: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsExecutionCommands(bb: ByteBuffer) -> ExecutionCommands { return ExecutionCommands(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var commandsCount: Int32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func commands(at index: Int32) -> TechPaws.Schemes.ExecutionCommand? { let o = _accessor.offset(4); return o == 0 ? nil : TechPaws.Schemes.ExecutionCommand(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public static func startExecutionCommands(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func addVectorOf(commands: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: commands, at: 0)  }
	public static func endExecutionCommands(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createExecutionCommands(_ fbb: FlatBufferBuilder,
		vectorOfCommands commands: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = ExecutionCommands.startExecutionCommands(fbb)
		ExecutionCommands.addVectorOf(commands: commands, fbb)
		return ExecutionCommands.endExecutionCommands(fbb, start: __start)
	}
}

public struct RequestCommands: FlatBufferObject {

	static func validateVersion() { FlatBuffersVersion_1_12_0() }
	public var __buffer: ByteBuffer! { return _accessor.bb }

	private var _accessor: Table
	public static func getRootAsRequestCommands(bb: ByteBuffer) -> RequestCommands { return RequestCommands(Table(bb: bb, position: Int32(bb.read(def: UOffset.self, position: bb.reader)) + Int32(bb.reader))) }

	private init(_ t: Table) { _accessor = t }
	public init(_ bb: ByteBuffer, o: Int32) { _accessor = Table(bb: bb, position: o) }

	public var commandsCount: Int32 { let o = _accessor.offset(4); return o == 0 ? 0 : _accessor.vector(count: o) }
	public func commands(at index: Int32) -> TechPaws.Schemes.RequestCommand? { let o = _accessor.offset(4); return o == 0 ? nil : TechPaws.Schemes.RequestCommand(_accessor.bb, o: _accessor.indirect(_accessor.vector(at: o) + index * 4)) }
	public static func startRequestCommands(_ fbb: FlatBufferBuilder) -> UOffset { fbb.startTable(with: 1) }
	public static func addVectorOf(commands: Offset<UOffset>, _ fbb: FlatBufferBuilder) { fbb.add(offset: commands, at: 0)  }
	public static func endRequestCommands(_ fbb: FlatBufferBuilder, start: UOffset) -> Offset<UOffset> { let end = Offset<UOffset>(offset: fbb.endTable(at: start)); return end }
	public static func createRequestCommands(_ fbb: FlatBufferBuilder,
		vectorOfCommands commands: Offset<UOffset> = Offset()) -> Offset<UOffset> {
		let __start = RequestCommands.startRequestCommands(fbb)
		RequestCommands.addVectorOf(commands: commands, fbb)
		return RequestCommands.endRequestCommands(fbb, start: __start)
	}
}

}

// MARK: - Schemes

}

// MARK: - TechPaws


